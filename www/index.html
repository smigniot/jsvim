<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="stylesheet" type="text/css" href="static/xterm.css" />
    <link rel="stylesheet" type="text/css" href="static/jsvim.css" />
    <script type="text/javascript" src="static/xterm.js"></script>
    <script type="text/javascript" src="static/jsvmain.js"></script>
<script type="text/javascript">
    function vim_getColumns() { return 80; }
    function vim_getRows() { return 24; }
    function vim_eventLoop() {
        //console.log("tick");
        Module.ccall("xvi_loop");
        setTimeout(vim_eventLoop, 50);
    }
    function vim_caretMove(row,col) {
        var c = caret();
        c.style.marginLeft = (6*col)+"px";
        c.style.marginTop = (row*0.75)+"em";
        c.setAttribute("data-row", row);
        c.setAttribute("data-col", col);
    }
    function vim_tputs(ptr_str,affcnt) {
        var text = UTF8ToString(ptr_str);
        if(text.startsWith("\u001b[<")) {
            var lc = text.split("[")[1].split("f")[0]
                .replace(/[<>]/g,"").split(";");
            var row = +(lc[0]);
            var col = +(lc[1]);
            if((affcnt==1) && (col==79)) {
                console.log("ignored tputs = ["+text+"], CLEAR END OF LINE "+row+" ?");
                // Heuristic till termcap doc rtfm'd
                vim_eraseLine();
            } else {
                vim_caretMove(row,col);
                //console.log("moved row#"+row+" col#"+col+" affcnt=",affcnt);
            }
        } else if("\u001b[K" == text) {
            vim_eraseLine();
        } else {
            console.log("Unhandled tputs = ["+JSON.stringify(text)+"]");
        }
        return -1;
    }
    function vim_eraseLine(c) {
        var ca = caret(),
            row = +(ca.getAttribute("data-row")),
            col = +(ca.getAttribute("data-col")),
            t = terminal(),
            lines = t.textContent.split("\n");

        // ensure row exists
        if(row >= lines.length) {
            var needed = row - lines.length+1;
            for(var i=0; i<needed; i++) {
                lines.push("");
            }
        }

        // ensure col exists
        var line = lines[row];
        if(line == undefined) {
            alert("AARGH "+row);
        }
        if(col >= line.length) {
            var needed = col - line.length+1;
            for(var i=0; i<needed; i++) {
                line += " ";
            }
        }

        // Delete starting at col
        line = line.substring(0,col);

        // commit line
        lines[row] = line;
        t.textContent = lines.join("\n");

        //console.log("Cleared line #"+row);
    }

    function vim_charIn(c) {
      document.querySelector("#terminal-container").term.write(String.fromCharCode(c));
      //console.log("IN", c);
    }
    function old_vim_charIn(c) {
        var ca = caret(),
            row = +(ca.getAttribute("data-row")),
            col = +(ca.getAttribute("data-col")),
            t = terminal(),
            lines = t.textContent.split("\n");

        // ensure row exists
        if(row >= lines.length) {
            var needed = row - lines.length+1;
            for(var i=0; i<needed; i++) {
                lines.push("");
            }
        }

        // ensure col exists
        var line = lines[row];
        if(col >= line.length) {
            var needed = col - line.length+1;
            for(var i=0; i<needed; i++) {
                line += " ";
            }
        }

        // insert at col
        var car = String.fromCharCode(+c);
        var replaced = 1;
        if((c==13)||(c==10)||(c==8)||(c==7)) { 
            car = "";
            replaced = 0;
        } else if(c<32) {
            console.log("FIXME: Unhandled control char = [",c,"], char = [",String.fromCharCode(+c),"]");
        }
        line = line.substring(0,col)+car+line.substring(col+replaced);

        // ensure maxcol
        var maxcol = vim_getColumns();
        if(line.length > maxcol) {
            line = line.substring(0,maxcol);
        }

        // commit line
        lines[row] = line;
        t.textContent = lines.join("\n");

        // ensure maxrow
        lines = t.textContent.split("\n");
        var maxrow = vim_getRows();
        if(lines.length > maxrow) {
            lines = lines.slice(0,maxrow);
        }
        t.textContent = lines.join("\n");

        if(c>=32) {
            vim_caretMove(row,col+1);
        } else if(c == 8) {
            vim_caretMove(row,col-1);
        } else if(c == 7) {
            t.className = ""; // XXX
            t.className = "bell";
            setTimeout(function() {
                t.className = "";
            },1200);
        } else if(c == 10) {
            vim_caretMove(row+1,col);
        } else if(c == 13) {
            vim_caretMove(row,0);
        }
    }

  /*
    function vim_tgetnum(id) {
        console.log("TGETNUM IN", id);
        var res = sec_vim_tgetnum(id);
        console.log("TGETNUM OUT", res);
        return res;
    }
    function sec_vim_tgetnum(id) {
        if("co" == id) { return 80 }
        if("li" == id) { return 25 }
        return 0;
    }
    */
    function vim_kbgetc() {
      return +0;
    }

    var Module = {
        charIn: function(c){},
        preRun: [(function() {
            function charIn(c) {
                 vim_charIn(c);
            }
            Module.charIn = charIn;
            FS.init(function() {
                var key_struct_list = _t._io_keys.splice(0,1);
                if(key_struct_list.length) {
                    var key_struct = key_struct_list[0];
                    var c_or_kc = key_struct.c;
                    if(c_or_kc == 0) {
                        c_or_kc = key_struct.kc;
                    }
                    console.log("IN["+(+c_or_kc)+"]", key_struct);
                    return +c_or_kc;
                }
                return null;
            },charIn,function(c) {
                console.log("CHARCODE", c);
                _dt.textContent += String.fromCharCode(c);
            })
        })],
        postRun: [],
        print: (function(s) {console.log(s);}),
        printErr: (function(s) {console.log(s);}),
        canvas: (function() {}),
        setStatus: function(text) {},
        totalDependencies: 0,
        monitorRunDependencies: function(left) {},
    };
</script>
  </head>
            <body>

    <div id="terminal-container"></div> 

    <script type="text/javascript">
    (function() {
        var memoryInitializer = '../src/xvi.html.mem';
        if (typeof Module['locateFile'] === 'function') {
            memoryInitializer = Module['locateFile'](memoryInitializer);
        } else if (Module['memoryInitializerPrefixURL']) {
            memoryInitializer = Module['memoryInitializerPrefixURL'] + memoryInitializer;
        }
        var xhr = Module['memoryInitializerRequest'] = new XMLHttpRequest();
        xhr.open('GET', memoryInitializer, true);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
    })();

    jsvimOnLoad();

    var script = document.createElement('script');
    script.src = "../src/xvi.js";
    document.body.appendChild(script);
    </script>
  </body>
</html>
<!-- vim: set ts=2 sw=2 sts=2 expandtab foldmethod=marker : --> 


